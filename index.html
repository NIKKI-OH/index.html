<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Christmas Magic</title>
    <style>
        body { margin: 0; overflow: hidden; background: radial-gradient(circle at center, #001510 0%, #000000 100%); }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #10ffaa; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            letter-spacing: 5px; text-transform: uppercase; font-size: 12px;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Gathering Stardust...</div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- åœºæ™¯è®¾ç½® ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 2, 12);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.2;

        // --- æå…‰å‘å…‰æ•ˆæœ (Bloom) ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.5, 0.1);
        composer.addPass(bloomPass);

        // --- ç²’å­ç³»ç»Ÿæ•°æ® ---
        const count = 40000;
        const geo = new THREE.BufferGeometry();
        const posGift = new Float32Array(count * 3);
        const posTree = new Float32Array(count * 3);
        const randoms = new Float32Array(count);

        for (let i = 0; i < count; i++) {
            const i3 = i * 3;
            // ç¤¼ç‰©ç›’ï¼šæ›´æœ‰è´¨æ„Ÿçš„ç©ºå¿ƒç«‹æ–¹ä½“
            posGift[i3] = (Math.random() - 0.5) * 4;
            posGift[i3+1] = (Math.random() - 0.5) * 4;
            posGift[i3+2] = (Math.random() - 0.5) * 4;

            // åœ£è¯æ ‘ï¼šåŒèºæ—‹æ˜Ÿäº‘ç»“æ„
            const progress = i / count;
            const angle = progress * Math.PI * 25; // æ—‹è½¬åœˆæ•°
            const radius = Math.pow(1.0 - progress, 1.5) * 4.5;
            const y = progress * 10 - 4;
            
            // åŠ å…¥éšæœºæ‰°åŠ¨è®©æ ‘çœ‹èµ·æ¥æ›´èŒ‚ç››
            const spread = (Math.random() - 0.5) * 0.5;
            posTree[i3] = Math.cos(angle) * (radius + spread);
            posTree[i3+1] = y + (Math.random() - 0.5) * 0.2;
            posTree[i3+2] = Math.sin(angle) * (radius + spread);

            randoms[i] = Math.random();
        }

        geo.setAttribute('position', new THREE.BufferAttribute(posGift, 3));
        geo.setAttribute('aTarget', new THREE.BufferAttribute(posTree, 3));
        geo.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

        // --- è‰ºæœ¯çº§ç€è‰²å™¨ (The Master Shader) ---
        const mat = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 },
                uColor1: { value: new THREE.Color("#00ffcc") }, // ç¿¡ç¿ 
                uColor2: { value: new THREE.Color("#ffdd44") }, // çº¯é‡‘
                uColor3: { value: new THREE.Color("#ff2255") }  // éœ“è™¹çº¢
            },
            vertexShader: `
                uniform float uTime;
                uniform float uMorph;
                uniform vec3 uColor1;
                uniform vec3 uColor2;
                uniform vec3 uColor3;
                attribute vec3 aTarget;
                attribute float aRandom;
                varying vec3 vColor;
                varying float vAlpha;

                // ç®€å•çš„å™ªæ³¢å‡½æ•°å®ç°
                float hash(float n) { return fract(sin(n) * 43758.5453123); }

                void main() {
                    vec3 pos = mix(position, aTarget, uMorph);
                    
                    // åŠ å…¥æµä½“æ³¢åŠ¨æ„Ÿ
                    float wave = sin(uTime * 1.5 + pos.y * 2.0 + aRandom * 6.28) * 0.15;
                    pos.x += wave;
                    pos.z += wave;

                    // é¢œè‰²é€»è¾‘ï¼šæ ¹æ®é«˜åº¦å’Œå½¢æ€åˆ‡æ¢
                    vec3 treeColor = mix(uColor1, uColor2, (pos.y + 4.0) / 8.0);
                    vColor = mix(uColor3, treeColor, uMorph);
                    
                    // è®©ä¸€éƒ¨åˆ†ç²’å­é—ªçƒ
                    float twinkle = sin(uTime * 5.0 + aRandom * 10.0) * 0.5 + 0.5;
                    vAlpha = twinkle * aRandom;

                    vec4 mvPos = modelViewMatrix * vec4(pos, 1.0);
                    gl_PointSize = (15.0 * aRandom + 5.0) * (10.0 / -mvPos.z);
                    gl_Position = projectionMatrix * mvPos;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;
                void main() {
                    // æ˜ŸèŠ’çº¹ç†
                    float dist = distance(gl_PointCoord, vec2(0.5));
                    float glow = 0.05 / dist;
                    glow = clamp(glow, 0.0, 1.0);
                    glow = pow(glow, 1.8);
                    
                    gl_FragColor = vec4(vColor * glow, glow * vAlpha);
                }
            `,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const points = new THREE.Points(geo, mat);
        scene.add(particles); // æ³¨æ„ï¼šè¿™é‡Œå¦‚æœæ˜¯æ‰‹åŠ¨æ‰“çš„è¯·æ”¹ä¸º scene.add(points);
        scene.add(points);

        // --- æŠ½å¥–æ–‡å­— (å…¨æ¯è´¨æ„Ÿ) ---
        function createHoloText(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 256;
            const ctx = canvas.getContext('2d');
            ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
            ctx.fillStyle = '#fff';
            ctx.font = 'italic bold 80px sans-serif';
            // æ·»åŠ å¤–å‘å…‰
            ctx.shadowBlur = 30; ctx.shadowColor = '#00ffcc';
            ctx.fillText(text, 512, 128);
            return new THREE.CanvasTexture(canvas);
        }

        const prizePlane = new THREE.Mesh(
            new THREE.PlaneGeometry(8, 2),
            new THREE.MeshBasicMaterial({ map: createHoloText(""), transparent: true, opacity: 0 })
        );
        prizePlane.position.y = 1;
        scene.add(prizePlane);

        // --- è‡ªåŠ¨æ¼”ç¤ºé€»è¾‘ ---
        let morphState = 0;
        const prizes = ["ç­”åº”ä½ ä¸€ä¸ªè¦æ±‚ âœ¨", "å¸¦ä½ å»åƒå¤§é¤ ğŸ²", "æ¸…ç©ºä½ çš„è´­ç‰©è½¦ ğŸ›’", "ä¸“å±æŒ‰æ‘©ä¸€æ¬¡ ğŸ’†"];
        
        setInterval(() => {
            morphState = morphState === 0 ? 1 : 0;
            if(morphState === 1) {
                setTimeout(() => {
                    const win = prizes[Math.floor(Math.random() * prizes.length)];
                    prizePlane.material.map = createHoloText(win);
                }, 1000);
            }
        }, 6000);

        // --- æ¸²æŸ“å¾ªç¯ ---
        const clock = new THREE.Clock();
        document.getElementById('loading').style.display = 'none';

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();
            const elapsed = clock.getElapsedTime();
            
            mat.uniforms.uTime.value = elapsed;
            mat.uniforms.uMorph.value = THREE.MathUtils.lerp(mat.uniforms.uMorph.value, morphState, 0.03);
            
            // æ–‡å­—æ·¡å…¥æ·¡å‡º
            prizePlane.material.opacity = THREE.MathUtils.smoothstep(mat.uniforms.uMorph.value, 0.8, 1.0);
            prizePlane.lookAt(camera.position);

            controls.update();
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
