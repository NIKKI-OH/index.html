<!DOCTYPE html>
<html lang="en">
<head>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
      "troika-three-text": "https://unpkg.com/troika-three-text@0.47.1/dist/troika-three-text.esm.js"
    }
  }
</script>
  <meta charset="UTF-8" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1.0, user-scalable=no"
  />
  <title>Magical Particle Christmas Tree</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #000;
      overflow: hidden;
      touch-action: none;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>

<script type="module">
/* =====================================================
   IMPORTS
===================================================== */
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.module.js';
import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.150.1/examples/jsm/postprocessing/UnrealBloomPass.js';

/* =====================================================
   CONFIG
===================================================== */
const isMobile = window.innerWidth < 768;
const PARTICLE_COUNT = isMobile ? 20000 : 50000;

/* =====================================================
   GLOBALS
===================================================== */
let scene, camera, renderer, composer;
let particleSystem, particleMaterial;
let clock;

let targetMorph = 0;   // 0 = Gift, 1 = Tree
let currentMorph = 0;

/* =====================================================
   SHADERS
===================================================== */

// ---------- Vertex Shader ----------
const particleVertexShader = `
precision highp float;

uniform float uTime;
uniform float uMorph;
uniform float uSize;

attribute vec3 positionGift;
attribute vec3 positionTree;
attribute float aRandom;

varying float vRandom;
varying float vMorph;

/* Simplex Noise (compact) */
vec4 permute(vec4 x) {
  return mod(((x*34.0)+1.0)*x, 289.0);
}

float snoise(vec3 v) {
  const vec2 C = vec2(1.0/6.0, 1.0/3.0);
  vec3 i = floor(v + dot(v, C.yyy));
  vec3 x0 = v - i + dot(i, C.xxx);
  vec3 g = step(x0.yzx, x0.xyz);
  vec3 l = 1.0 - g;
  vec3 i1 = min(g.xyz, l.zxy);
  vec3 i2 = max(g.xyz, l.zxy);
  vec3 x1 = x0 - i1 + C.xxx;
  vec3 x2 = x0 - i2 + C.yyy;
  vec3 x3 = x0 - 0.5;
  i = mod(i, 289.0);
  vec4 p = permute(
    permute(
      permute(i.z + vec4(0.0, i1.z, i2.z, 1.0))
    + i.y + vec4(0.0, i1.y, i2.y, 1.0))
  + i.x + vec4(0.0, i1.x, i2.x, 1.0));
  vec4 j = p - 49.0 * floor(p / 49.0);
  vec4 x_ = floor(j / 7.0);
  vec4 y_ = floor(j - 7.0 * x_);
  vec4 x = (x_ * 2.0 + 0.5) / 7.0 - 1.0;
  vec4 y = (y_ * 2.0 + 0.5) / 7.0 - 1.0;
  vec4 h = 1.0 - abs(x) - abs(y);
  vec4 b0 = vec4(x.xy, y.xy);
  vec4 b1 = vec4(x.zw, y.zw);
  vec4 s0 = floor(b0)*2.0 + 1.0;
  vec4 s1 = floor(b1)*2.0 + 1.0;
  vec4 sh = -step(h, vec4(0.0));
  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
  vec3 g0 = vec3(a0.xy, h.x);
  vec3 g1 = vec3(a0.zw, h.y);
  vec3 g2 = vec3(a1.xy, h.z);
  vec3 g3 = vec3(a1.zw, h.w);
  vec4 norm = inversesqrt(vec4(
    dot(g0,g0), dot(g1,g1), dot(g2,g2), dot(g3,g3)
  ));
  g0 *= norm.x;
  g1 *= norm.y;
  g2 *= norm.z;
  g3 *= norm.w;
  vec4 m = max(0.6 - vec4(
    dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)
  ), 0.0);
  m = m * m;
  return 42.0 * dot(
    m*m,
    vec4(
      dot(g0,x0), dot(g1,x1),
      dot(g2,x2), dot(g3,x3)
    )
  );
}

void main() {
  vRandom = aRandom;
  vMorph = uMorph;

  vec3 pos = mix(positionGift, positionTree, uMorph);

  float noise = snoise(pos * 0.8 + uTime * 0.4);
  float swirl = sin(uMorph * 3.1415) * 0.8;
  pos += normalize(pos) * noise * swirl;

  pos.y += snoise(pos + uTime * 0.2) * 0.15;

  vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
  gl_Position = projectionMatrix * mvPosition;
  gl_PointSize = uSize * (1.0 / -mvPosition.z);
}
`;

// ---------- Fragment Shader ----------
const particleFragmentShader = `
precision highp float;

uniform vec3 uGiftColor;
uniform vec3 uTreeColorA;
uniform vec3 uTreeColorB;
uniform vec3 uGold;

varying float vRandom;
varying float vMorph;

void main() {
  vec2 uv = gl_PointCoord - 0.5;
  float d = length(uv);

  float alpha = smoothstep(0.5, 0.0, d) * 0.85;

  vec3 giftColor = uGiftColor;
  vec3 treeGradient = mix(uTreeColorA, uTreeColorB, vRandom);
  vec3 treeColor = mix(treeGradient, uGold, pow(vRandom, 4.0));

  vec3 color = mix(giftColor, treeColor, vMorph);

  gl_FragColor = vec4(color, alpha);
}
`;

/* =====================================================
   INIT
===================================================== */
init();
animate();

function init() {
  clock = new THREE.Clock();

  scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x000000, 0.06);

  camera = new THREE.PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    0.1,
    100
  );
  camera.position.set(0, 0, 12);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
  renderer.setClearColor(0x000000, 1);
  document.body.appendChild(renderer.domElement);

  // Post Processing
  composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));

  const bloomPass = new UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    1.6,
    0.4,
    0.1
  );
  composer.addPass(bloomPass);

  createParticles();

  window.addEventListener('resize', onResize);
  window.addEventListener('click', () => {
    targetMorph = targetMorph === 0 ? 1 : 0;
  });
}

/* =====================================================
   PARTICLES
===================================================== */
function createParticles() {
  const geometry = new THREE.BufferGeometry();

  const gift = new Float32Array(PARTICLE_COUNT * 3);
  const tree = new Float32Array(PARTICLE_COUNT * 3);
  const randoms = new Float32Array(PARTICLE_COUNT);

  const cubeSize = 4;
  const treeHeight = 6;
  const treeRadius = 2.5;

  for (let i = 0; i < PARTICLE_COUNT; i++) {
    gift[i*3]     = (Math.random()-0.5) * cubeSize;
    gift[i*3 + 1] = (Math.random()-0.5) * cubeSize;
    gift[i*3 + 2] = (Math.random()-0.5) * cubeSize;

    const t = Math.random();
    const angle = t * Math.PI * 12;
    const radius = (1.0 - t) * treeRadius;

    tree[i*3]     = Math.cos(angle) * radius;
    tree[i*3 + 1] = t * treeHeight - treeHeight / 2;
    tree[i*3 + 2] = Math.sin(angle) * radius;

    randoms[i] = Math.random();
  }

  geometry.setAttribute('positionGift', new THREE.BufferAttribute(gift, 3));
  geometry.setAttribute('positionTree', new THREE.BufferAttribute(tree, 3));
  geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 1));

  particleMaterial = new THREE.ShaderMaterial({
    vertexShader: particleVertexShader,
    fragmentShader: particleFragmentShader,
    transparent: true,
    depthWrite: false,
    blending: THREE.AdditiveBlending,
    uniforms: {
      uTime: { value: 0 },
      uMorph: { value: 0 },
      uSize: { value: isMobile ? 18 : 24 },
      uGiftColor: { value: new THREE.Color('#D10056') },
      uTreeColorA: { value: new THREE.Color('#005533') },
      uTreeColorB: { value: new THREE.Color('#00FFFF') },
      uGold: { value: new THREE.Color('#FFD36A') }
    }
  });

  particleSystem = new THREE.Points(geometry, particleMaterial);
  scene.add(particleSystem);
}

/* =====================================================
   LOOP
===================================================== */
function animate() {
  requestAnimationFrame(animate);

  const t = clock.getElapsedTime();
  currentMorph += (targetMorph - currentMorph) * 0.04;

  particleMaterial.uniforms.uTime.value = t;
  particleMaterial.uniforms.uMorph.value = currentMorph;

  composer.render();
}

/* =====================================================
   RESIZE
===================================================== */
function onResize() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  composer.setSize(window.innerWidth, window.innerHeight);
}

/* =====================================================
   MediaPipe Placeholder
===================================================== */
// TODO:
// - 接入 MediaPipe Hands
// - Open Hand → targetMorph = 1
// - Point Gesture → Tarot Selection
</script>

</body>
</html>
