<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ£è¯é­”æ³•ï¼šæ‰‹åŠ¿æ§åˆ¶</title>
    <style>
        * { margin: 0; padding: 0; }
        body { 
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
        }
        
        #container {
            position: fixed;
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at 50% 50%, #0a0a1a 0%, #000 100%);
        }
        
        #ui {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            text-align: center;
            font-size: 16px;
            z-index: 100;
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(8px);
            border-radius: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            letter-spacing: 1px;
            opacity: 1;
            transition: opacity 2s;
        }
        
        #gesture-indicator {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: #fff;
            font-size: 14px;
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .gesture-icon {
            font-size: 20px;
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            z-index: 1000;
        }
        
        #video-input {
            display: none;
        }
    </style>
</head>
<body>
    <div id="ui">æ¡æ‹³ ğŸ ç¤¼ç‰© Â· å¼ æ‰‹ ğŸ„ åœ£è¯æ ‘</div>
    <div id="gesture-indicator">
        <span class="gesture-icon">ğŸ‘‹</span>
        <span>ç­‰å¾…æ‰‹åŠ¿æ£€æµ‹</span>
    </div>
    <div id="loading">æ­£åœ¨åŠ è½½...</div>
    <video id="video-input" playsinline></video>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer;
        let particles, particleGeometry, particleMaterial;
        let currentMorph = 0, targetMorph = 0;
        let isHandDetected = false;

        // åˆå§‹åŒ–Three.jsåœºæ™¯
        function initScene() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 12);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                preserveDrawingBuffer: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            document.getElementById('container').appendChild(renderer.domElement);
            
            // æ·»åŠ ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // æ·»åŠ ä¸»å…‰æº
            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(10, 10, 10);
            scene.add(mainLight);
            
            // æ·»åŠ è½®å»“å…‰
            const rimLight = new THREE.DirectionalLight(0x4a90e2, 0.3);
            rimLight.position.set(-10, -5, -10);
            scene.add(rimLight);
            
            createParticleSystem();
            animate();
        }

        // åˆ›å»ºç²’å­ç³»ç»Ÿ
        function createParticleSystem() {
            const particleCount = 15000;
            
            // åˆ›å»ºå‡ ä½•ä½“
            particleGeometry = new THREE.BufferGeometry();
            
            // åˆå§‹ä½ç½®ï¼ˆç¤¼ç‰©çŠ¶æ€ï¼‰
            const initialPositions = new Float32Array(particleCount * 3);
            // ç›®æ ‡ä½ç½®ï¼ˆåœ£è¯æ ‘çŠ¶æ€ï¼‰
            const targetPositions = new Float32Array(particleCount * 3);
            // ç²’å­å±æ€§ï¼š[ç±»å‹, å¤§å°, éšæœºç›¸ä½]
            const attributes = new Float32Array(particleCount * 3);
            
            for (let i = 0; i < particleCount; i++) {
                const i3 = i * 3;
                const type = Math.random();
                
                // ç²’å­ç±»å‹ï¼š0=çº¢è‰²ç¤¼ç‰©ï¼Œ1=é‡‘è‰²ä¸å¸¦ï¼Œ2=ç»¿è‰²æ ‘å¶ï¼Œ3=è£…é¥°çƒ
                let particleType = 0;
                if (type < 0.1) particleType = 1;      // 10% é‡‘è‰²ä¸å¸¦
                else if (type < 0.25) particleType = 3; // 15% è£…é¥°çƒ
                else if (type < 0.7) particleType = 2;  // 45% ç»¿è‰²æ ‘å¶
                // å…¶ä½™ 30% ä¸ºçº¢è‰²ç¤¼ç‰©
                
                // --- ç¤¼ç‰©ä½ç½®ï¼ˆç«‹æ–¹ä½“ï¼‰---
                const giftSize = 4;
                const face = Math.floor(Math.random() * 6);
                const u = (Math.random() - 0.5) * 2;
                const v = (Math.random() - 0.5) * 2;
                
                switch(face) {
                    case 0: // å³é¢
                        initialPositions[i3] = giftSize;
                        initialPositions[i3+1] = u;
                        initialPositions[i3+2] = v;
                        break;
                    case 1: // å·¦é¢
                        initialPositions[i3] = -giftSize;
                        initialPositions[i3+1] = u;
                        initialPositions[i3+2] = v;
                        break;
                    case 2: // ä¸Šé¢
                        initialPositions[i3] = u;
                        initialPositions[i3+1] = giftSize;
                        initialPositions[i3+2] = v;
                        break;
                    case 3: // ä¸‹é¢
                        initialPositions[i3] = u;
                        initialPositions[i3+1] = -giftSize;
                        initialPositions[i3+2] = v;
                        break;
                    case 4: // å‰é¢
                        initialPositions[i3] = u;
                        initialPositions[i3+1] = v;
                        initialPositions[i3+2] = giftSize;
                        break;
                    case 5: // åé¢
                        initialPositions[i3] = u;
                        initialPositions[i3+1] = v;
                        initialPositions[i3+2] = -giftSize;
                        break;
                }
                
                // --- åœ£è¯æ ‘ä½ç½®ï¼ˆé”¥å½¢èºæ—‹ï¼‰---
                const t = i / particleCount;
                const height = t * 12 - 4;
                const radius = (1 - t * 0.8) * 5;
                const angle = Math.PI * 6 * t;
                
                targetPositions[i3] = Math.cos(angle) * radius * (0.8 + Math.random() * 0.4);
                targetPositions[i3+1] = height;
                targetPositions[i3+2] = Math.sin(angle) * radius * (0.8 + Math.random() * 0.4);
                
                // å¦‚æœæ˜¯è£…é¥°çƒï¼Œå¾€å¤–åç§»ä¸€äº›
                if (particleType === 3) {
                    targetPositions[i3] *= 1.3;
                    targetPositions[i3+2] *= 1.3;
                }
                
                // å¦‚æœæ˜¯æ˜Ÿæ˜Ÿï¼ˆé¡¶éƒ¨ï¼‰
                if (i < 200) { // é¡¶éƒ¨200ä¸ªç²’å­ç»„æˆæ˜Ÿæ˜Ÿ
                    particleType = 1;
                    const starRadius = 2 * Math.sin(t * Math.PI * 5);
                    targetPositions[i3] = Math.cos(angle * 5) * starRadius;
                    targetPositions[i3+1] = 8;
                    targetPositions[i3+2] = Math.sin(angle * 5) * starRadius;
                }
                
                attributes[i3] = particleType;               // ç±»å‹
                attributes[i3+1] = 0.8 + Math.random() * 0.4; // å¤§å°
                attributes[i3+2] = Math.random() * Math.PI * 2; // ç›¸ä½
            }
            
            // è®¾ç½®å‡ ä½•ä½“å±æ€§
            particleGeometry.setAttribute('position', new THREE.BufferAttribute(initialPositions, 3));
            particleGeometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
            particleGeometry.setAttribute('attributes', new THREE.BufferAttribute(attributes, 3));
            
            // åˆ›å»ºç²’å­æè´¨
            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    morph: { value: 0 }
                },
                vertexShader: `
                    uniform float time;
                    uniform float morph;
                    
                    attribute vec3 targetPosition;
                    attribute vec3 attributes;
                    
                    varying vec3 vColor;
                    varying float vAlpha;
                    
                    void main() {
                        float type = attributes.x;
                        float size = attributes.y;
                        float phase = attributes.z;
                        
                        // å¹³æ»‘æ’å€¼
                        float t = morph;
                        t = t * t * (3.0 - 2.0 * t); // å¹³æ»‘ç¼“åŠ¨
                        vec3 pos = mix(position, targetPosition, t);
                        
                        // è½»å¾®æµ®åŠ¨æ•ˆæœ
                        float floatAmount = sin(time * 1.5 + phase) * 0.05;
                        pos.y += floatAmount * (1.0 - t * 0.5);
                        
                        // ç¼“æ…¢æ—‹è½¬ï¼ˆç¤¼ç‰©çŠ¶æ€ä¸‹æ›´æ˜æ˜¾ï¼‰
                        float rotation = time * 0.3 * (1.0 - t);
                        float c = cos(rotation);
                        float s = sin(rotation);
                        pos.xz = mat2(c, -s, s, c) * pos.xz;
                        
                        // è®¾ç½®é¢œè‰²
                        if (t < 0.5) {
                            // ç¤¼ç‰©é¢œè‰²
                            if (type > 0.9) {
                                vColor = vec3(1.0, 0.85, 0.3); // é‡‘è‰²
                            } else {
                                vColor = vec3(0.95, 0.2, 0.2); // çº¢è‰²
                            }
                        } else {
                            // åœ£è¯æ ‘é¢œè‰²
                            if (type > 0.9) {
                                vColor = vec3(1.0, 0.9, 0.4); // æ˜Ÿæ˜Ÿ/è£…é¥°
                            } else if (type > 0.8) {
                                // å¤šå½©è£…é¥°çƒ
                                float hue = phase / 6.28;
                                vColor = 0.6 + 0.4 * cos(vec3(0.0, 2.094, 4.188) + hue * 6.28);
                            } else {
                                // æ ‘å¶é¢œè‰²æ¸å˜
                                float green = 0.3 + 0.7 * (pos.y + 4.0) / 12.0;
                                vColor = mix(vec3(0.1, 0.5, 0.2), vec3(0.4, 0.9, 0.5), green);
                            }
                        }
                        
                        vAlpha = 0.9 + 0.1 * sin(time + phase);
                        
                        vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                        gl_Position = projectionMatrix * mvPosition;
                        
                        // ç²’å­å¤§å°
                        float baseSize = 6.0;
                        if (type > 0.9) baseSize = 8.0; // æ˜Ÿæ˜Ÿ/ä¸å¸¦
                        if (type > 0.8) baseSize = 10.0; // è£…é¥°çƒ
                        
                        gl_PointSize = baseSize * size * (300.0 / -mvPosition.z);
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    
                    void main() {
                        vec2 uv = gl_PointCoord - vec2(0.5);
                        float dist = length(uv);
                        
                        if (dist > 0.5) discard;
                        
                        // åœ†å½¢ç²’å­ï¼Œè¾¹ç¼˜æŸ”å’Œ
                        float alpha = 1.0 - smoothstep(0.4, 0.5, dist);
                        
                        // å†…å‘å…‰
                        float innerGlow = 1.0 - dist * 1.8;
                        innerGlow = pow(innerGlow, 2.0);
                        
                        gl_FragColor = vec4(vColor, alpha * innerGlow * vAlpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.NormalBlending
            });
            
            // åˆ›å»ºç²’å­ç³»ç»Ÿ
            particles = new THREE.Points(particleGeometry, particleMaterial);
            scene.add(particles);
        }

        // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
        async function initHandTracking() {
            const video = document.getElementById('video-input');
            
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 0,
                minDetectionConfidence: 0.6,
                minTrackingConfidence: 0.6
            });
            
            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    if (!isHandDetected) {
                        isHandDetected = true;
                        updateGestureIndicator(true);
                    }
                    
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // è®¡ç®—æ‰‹æŒ‡å¼ å¼€ç¨‹åº¦
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const middleTip = landmarks[12];
                    const ringTip = landmarks[16];
                    const pinkyTip = landmarks[20];
                    
                    // è®¡ç®—æŒ‡å°–åˆ°æŒå¿ƒçš„å¹³å‡è·ç¦»
                    const wrist = landmarks[0];
                    const distances = [
                        Math.sqrt(Math.pow(thumbTip.x - wrist.x, 2) + Math.pow(thumbTip.y - wrist.y, 2)),
                        Math.sqrt(Math.pow(indexTip.x - wrist.x, 2) + Math.pow(indexTip.y - wrist.y, 2)),
                        Math.sqrt(Math.pow(middleTip.x - wrist.x, 2) + Math.pow(middleTip.y - wrist.y, 2)),
                        Math.sqrt(Math.pow(ringTip.x - wrist.x, 2) + Math.pow(ringTip.y - wrist.y, 2)),
                        Math.sqrt(Math.pow(pinkyTip.x - wrist.x, 2) + Math.pow(pinkyTip.y - wrist.y, 2))
                    ];
                    
                    const avgDistance = distances.reduce((a, b) => a + b) / distances.length;
                    
                    // æ˜ å°„åˆ°0-1èŒƒå›´
                    let morphValue = (avgDistance - 0.1) / 0.2;
                    morphValue = Math.max(0, Math.min(1, morphValue));
                    
                    targetMorph = morphValue;
                    
                } else {
                    if (isHandDetected) {
                        isHandDetected = false;
                        updateGestureIndicator(false);
                    }
                    targetMorph = 0;
                }
            });
            
            const camera = new Camera(video, {
                onFrame: async () => {
                    try {
                        await hands.send({ image: video });
                    } catch (e) {
                        console.log('Camera error:', e);
                    }
                },
                width: 320,
                height: 240
            });
            
            try {
                await camera.start();
                document.getElementById('loading').style.display = 'none';
                document.getElementById('ui').style.opacity = 1;
                
                // 5ç§’åæ·¡å‡ºæç¤º
                setTimeout(() => {
                    document.getElementById('ui').style.opacity = 0;
                }, 5000);
                
            } catch (error) {
                console.error('Camera initialization failed:', error);
                document.getElementById('loading').textContent = 'è¯·å…è®¸æ‘„åƒå¤´æƒé™';
            }
        }

        // æ›´æ–°æ‰‹åŠ¿æŒ‡ç¤ºå™¨
        function updateGestureIndicator(detected) {
            const indicator = document.getElementById('gesture-indicator');
            const icon = indicator.querySelector('.gesture-icon');
            const text = indicator.querySelector('span:last-child');
            
            if (detected) {
                if (targetMorph > 0.7) {
                    icon.textContent = 'âœ‹';
                    text.textContent = 'åœ£è¯æ ‘å½¢æ€';
                } else if (targetMorph < 0.3) {
                    icon.textContent = 'âœŠ';
                    text.textContent = 'ç¤¼ç‰©å½¢æ€';
                } else {
                    icon.textContent = 'âœ‹';
                    text.textContent = 'å˜å½¢ä¸­...';
                }
            } else {
                icon.textContent = 'ğŸ‘‹';
                text.textContent = 'è¯·å°†æ‰‹æ”¾å…¥ç”»é¢ä¸­';
            }
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);
            
            const time = Date.now() * 0.001;
            
            // å¹³æ»‘è¿‡æ¸¡å˜å½¢å€¼
            currentMorph += (targetMorph - currentMorph) * 0.05;
            
            // æ›´æ–°ç²’å­æè´¨
            if (particleMaterial) {
                particleMaterial.uniforms.time.value = time;
                particleMaterial.uniforms.morph.value = currentMorph;
            }
            
            // ç¼“æ…¢æ—‹è½¬åœºæ™¯
            scene.rotation.y = time * 0.05;
            
            // æ¸²æŸ“
            renderer.render(scene, camera);
        }

        // çª—å£å¤§å°è°ƒæ•´
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // åˆå§‹åŒ–
        window.addEventListener('DOMContentLoaded', () => {
            initScene();
            initHandTracking();
            window.addEventListener('resize', onWindowResize);
        });

        // ç‚¹å‡»åˆ‡æ¢å…¨å±
        document.addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(console.log);
            }
        });
    </script>
</body>
</html>
