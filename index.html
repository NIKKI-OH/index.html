<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Christmas Magic: Hand Gesture Control</title>
    <style>
        * { margin: 0; padding: 0; }
        body { 
            margin: 0; 
            overflow: hidden; 
            background: #0a0a14; 
            font-family: 'Arial', sans-serif;
        }
        
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
            position: fixed;
            background: radial-gradient(ellipse at center, 
                #0d1b2a 0%, 
                #050a14 40%, 
                #000000 100%);
        }
        
        #ui { 
            position: fixed; 
            top: 20px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: #fff; 
            z-index: 100; 
            pointer-events: none; 
            text-align: center; 
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 18px;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.8s ease;
        }
        
        #ui span {
            color: #4dff91;
            text-shadow: 0 0 10px #00ff88;
        }
        
        #status {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.7);
            z-index: 100;
            font-size: 14px;
            text-align: center;
            background: rgba(0, 0, 0, 0.2);
            padding: 10px 20px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #hand-indicator {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: rgba(77, 255, 145, 0.1);
            border: 2px solid rgba(77, 255, 145, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            opacity: 0;
            transition: all 0.3s ease;
        }
        
        .loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 1000;
        }
        
        #video-input { 
            position: absolute; 
            opacity: 0; 
            width: 1px; 
            height: 1px; 
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="ui">ğŸ„ <span>æ¡æ‹³å˜ç¤¼ç‰© Â· å¼ æ‰‹å˜åœ£è¯æ ‘</span> ğŸ</div>
    <div id="status">ç­‰å¾…æ‰‹åŠ¿æ£€æµ‹...</div>
    <div id="hand-indicator">ğŸ‘‹</div>
    <div class="loader" id="loader">åŠ è½½ä¸­...</div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        let targetMorph = 0, currentMorph = 0;
        let handDetected = false;

        // --- 1. åœºæ™¯ä¸æ¸²æŸ“è®¾ç½® ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x0a0a14, 10, 25);
        
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 12);
        camera.lookAt(0, 1, 0);

        const renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            powerPreference: "high-performance",
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // åæœŸæ•ˆæœ
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const bloom = new UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.2,  // å¼ºåº¦
            0.4,  // åŠå¾„
            0.8   // é˜ˆå€¼
        );
        composer.addPass(bloom);

        // --- 2. ç¯å…‰ç³»ç»Ÿ ---
        const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1.2);
        mainLight.position.set(5, 10, 7);
        mainLight.castShadow = true;
        mainLight.shadow.mapSize.width = 2048;
        mainLight.shadow.mapSize.height = 2048;
        scene.add(mainLight);

        const rimLight = new THREE.DirectionalLight(0x4dff91, 0.5);
        rimLight.position.set(-5, 5, -5);
        scene.add(rimLight);

        // å½©è‰²ç‚¹å…‰æºï¼ˆè£…é¥°ç”¨ï¼‰
        const pointLights = [];
        const colors = [0xff4444, 0x44ff44, 0x4444ff, 0xffff44, 0xff44ff, 0x44ffff];
        for(let i = 0; i < 6; i++) {
            const light = new THREE.PointLight(colors[i], 0.8, 15);
            light.position.set(
                Math.cos(i * Math.PI/3) * 8,
                3,
                Math.sin(i * Math.PI/3) * 8
            );
            scene.add(light);
            pointLights.push(light);
        }

        // --- 3. åœ°é¢ ---
        const groundGeometry = new THREE.CircleGeometry(20, 32);
        const groundMaterial = new THREE.MeshStandardMaterial({
            color: 0x0a1420,
            roughness: 0.8,
            metalness: 0.2
        });
        const ground = new THREE.Mesh(groundGeometry, groundMaterial);
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -3;
        ground.receiveShadow = true;
        scene.add(ground);

        // --- 4. ä¸»è¦ç²’å­ç³»ç»Ÿï¼ˆç¤¼ç‰© â†” åœ£è¯æ ‘ï¼‰---
        const particleCount = 25000;
        const geometry = new THREE.BufferGeometry();
        
        const positions = new Float32Array(particleCount * 3);
        const targetPositions = new Float32Array(particleCount * 3);
        const attributes = new Float32Array(particleCount * 3); // [type, size, phase]

        // ç”Ÿæˆç¤¼ç‰©ç²’å­ï¼ˆç«‹æ–¹ä½“å½¢çŠ¶ï¼‰
        const giftSize = 3.5;
        for(let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const type = Math.random();
            
            // ç²’å­ç±»å‹ï¼š0-æ™®é€šï¼Œ1-ä¸å¸¦ï¼Œ2-è£…é¥°
            let particleType = 0;
            if(type < 0.1) particleType = 1; // 10% ä¸å¸¦
            else if(type < 0.25) particleType = 2; // 15% è£…é¥°
            
            // ç¤¼ç‰©ä½ç½®ï¼ˆç«‹æ–¹ä½“ï¼‰
            const face = Math.floor(Math.random() * 6);
            const u = (Math.random() - 0.5) * 2;
            const v = (Math.random() - 0.5) * 2;
            
            switch(face) {
                case 0: positions[i3] = giftSize; positions[i3+1] = u; positions[i3+2] = v; break;
                case 1: positions[i3] = -giftSize; positions[i3+1] = u; positions[i3+2] = v; break;
                case 2: positions[i3] = u; positions[i3+1] = giftSize; positions[i3+2] = v; break;
                case 3: positions[i3] = u; positions[i3+1] = -giftSize; positions[i3+2] = v; break;
                case 4: positions[i3] = u; positions[i3+1] = v; positions[i3+2] = giftSize; break;
                case 5: positions[i3] = u; positions[i3+1] = v; positions[i3+2] = -giftSize; break;
            }
            
            // åœ£è¯æ ‘ä½ç½®ï¼ˆé”¥å½¢èºæ—‹ï¼‰
            const t = i / particleCount;
            const height = t * 10 - 2;
            const radius = (1 - t) * 4;
            const angle = Math.PI * 8 * t + Math.random() * Math.PI * 0.5;
            
            targetPositions[i3] = Math.cos(angle) * radius * (0.8 + Math.random() * 0.4);
            targetPositions[i3+1] = height;
            targetPositions[i3+2] = Math.sin(angle) * radius * (0.8 + Math.random() * 0.4);
            
            // è£…é¥°çƒä½ç½®è°ƒæ•´
            if(particleType === 2) {
                targetPositions[i3] *= 1.3;
                targetPositions[i3+2] *= 1.3;
            }
            
            attributes[i3] = particleType;
            attributes[i3+1] = 0.5 + Math.random() * 0.5; // å¤§å°
            attributes[i3+2] = Math.random() * Math.PI * 2; // ç›¸ä½
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
        geometry.setAttribute('attributes', new THREE.BufferAttribute(attributes, 3));

        const particleMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                morph: { value: 0 },
                lightPosition: { value: mainLight.position }
            },
            vertexShader: `
                uniform float time;
                uniform float morph;
                uniform vec3 lightPosition;
                
                attribute vec3 targetPosition;
                attribute vec3 attributes;
                
                varying vec3 vColor;
                varying float vAlpha;
                varying float vType;
                
                void main() {
                    float type = attributes.x;
                    float size = attributes.y;
                    float phase = attributes.z;
                    
                    // å¹³æ»‘å˜å½¢
                    float smoothMorph = morph * morph * (3.0 - 2.0 * morph);
                    vec3 pos = mix(position, targetPosition, smoothMorph);
                    
                    // æ·»åŠ è½»å¾®æµ®åŠ¨åŠ¨ç”»
                    float floatOffset = sin(time * 2.0 + phase) * 0.1 * (1.0 - smoothMorph * 0.5);
                    pos.y += floatOffset;
                    
                    // æ—‹è½¬åŠ¨ç”»ï¼ˆåªåœ¨ç¤¼ç‰©çŠ¶æ€æ˜æ˜¾ï¼‰
                    float rotation = time * 0.5 * (1.0 - smoothMorph);
                    mat2 rotMat = mat2(cos(rotation), -sin(rotation), sin(rotation), cos(rotation));
                    pos.xz *= rotMat;
                    
                    // é¢œè‰²è®¡ç®—
                    if(morph < 0.5) {
                        // ç¤¼ç‰©é¢œè‰²
                        if(type > 0.9) {
                            vColor = vec3(1.0, 0.8, 0.2); // é‡‘è‰²ä¸å¸¦
                        } else if(type > 0.75) {
                            // å¤šå½©è£…é¥°
                            float hue = phase / (2.0 * 3.14159);
                            vColor = 0.5 + 0.5 * cos(vec3(0.0, 2.094, 4.188) + hue * 6.283);
                        } else {
                            vColor = vec3(0.9, 0.1, 0.1); // çº¢è‰²ç¤¼ç‰©ç›’
                        }
                    } else {
                        // åœ£è¯æ ‘é¢œè‰²
                        if(type > 0.9) {
                            vColor = vec3(1.0, 0.9, 0.3); // æ˜Ÿæ˜Ÿ/è£…é¥°
                        } else if(type > 0.75) {
                            // è£…é¥°çƒ
                            float hue = phase / (2.0 * 3.14159);
                            vColor = 0.7 + 0.3 * cos(vec3(0.0, 2.094, 4.188) + hue * 6.283);
                        } else {
                            // æ ‘å¶æ¸å˜
                            float greenFactor = 0.3 + 0.7 * (pos.y + 2.0) / 12.0;
                            vColor = mix(vec3(0.1, 0.4, 0.2), vec3(0.3, 0.9, 0.5), greenFactor);
                        }
                    }
                    
                    // æ·»åŠ å…‰ç…§æ•ˆæœ
                    vec3 normal = normalize(pos);
                    vec3 lightDir = normalize(lightPosition - pos);
                    float diff = max(dot(normal, lightDir), 0.0);
                    vColor += diff * 0.3;
                    
                    vType = type;
                    vAlpha = 0.8 + 0.2 * sin(time + phase);
                    
                    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                    gl_Position = projectionMatrix * mvPosition;
                    
                    // ç²’å­å¤§å°
                    float baseSize = 5.0;
                    if(type > 0.9) baseSize = 7.0;
                    if(type > 0.75) baseSize = 9.0;
                    
                    gl_PointSize = baseSize * size * (300.0 / -mvPosition.z);
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                varying float vAlpha;
                varying float vType;
                
                void main() {
                    vec2 uv = gl_PointCoord - vec2(0.5);
                    float dist = length(uv);
                    
                    if(dist > 0.5) discard;
                    
                    // åœ†å½¢ç²’å­
                    float circle = 1.0 - smoothstep(0.4, 0.5, dist);
                    
                    // å†…éƒ¨å…‰æ™•
                    float innerGlow = 1.0 - dist * 1.8;
                    
                    // æ˜Ÿæ˜Ÿå½¢çŠ¶ï¼ˆå¯¹type=1çš„ç²’å­ï¼‰
                    float star = 1.0;
                    if(vType > 0.9) {
                        float angle = atan(uv.y, uv.x);
                        float starShape = cos(angle * 5.0) * 0.3 + 0.7;
                        star = smoothstep(0.3, 0.4, starShape);
                    }
                    
                    float alpha = circle * innerGlow * star * vAlpha;
                    
                    gl_FragColor = vec4(vColor, alpha);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, particleMaterial);
        scene.add(particles);

        // --- 5. ç‰¹æ•ˆç²’å­ï¼ˆé­”æ³•å…‰ç‚¹ï¼‰---
        const effectCount = 800;
        const effectGeometry = new THREE.BufferGeometry();
        const effectPositions = new Float32Array(effectCount * 3);
        const effectAttributes = new Float32Array(effectCount * 2); // [speed, offset]
        
        for(let i = 0; i < effectCount; i++) {
            const i3 = i * 3;
            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 8;
            const height = Math.random() * 8 - 2;
            
            effectPositions[i3] = Math.cos(angle) * radius;
            effectPositions[i3+1] = height;
            effectPositions[i3+2] = Math.sin(angle) * radius;
            
            effectAttributes[i*2] = 0.5 + Math.random(); // speed
            effectAttributes[i*2+1] = Math.random() * Math.PI * 2; // offset
        }
        
        effectGeometry.setAttribute('position', new THREE.BufferAttribute(effectPositions, 3));
        effectGeometry.setAttribute('attributes', new THREE.BufferAttribute(effectAttributes, 2));
        
        const effectMaterial = new THREE.PointsMaterial({
            color: 0x4dff91,
            size: 0.8,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending
        });
        
        const effectParticles = new THREE.Points(effectGeometry, effectMaterial);
        scene.add(effectParticles);

        // --- 6. é›ªèŠ±èƒŒæ™¯ ---
        const snowCount = 2000;
        const snowGeometry = new THREE.BufferGeometry();
        const snowPositions = new Float32Array(snowCount * 3);
        
        for(let i = 0; i < snowCount; i++) {
            snowPositions[i*3] = (Math.random() - 0.5) * 40;
            snowPositions[i*3+1] = Math.random() * 20 - 5;
            snowPositions[i*3+2] = (Math.random() - 0.5) * 40;
        }
        
        snowGeometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
        
        const snowMaterial = new THREE.PointsMaterial({
            color: 0x88ccff,
            size: 0.3,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending
        });
        
        const snow = new THREE.Points(snowGeometry, snowMaterial);
        scene.add(snow);

        // --- 7. æ‰‹åŠ¿äº¤äº’ ---
        async function initHandTracking() {
            const video = document.getElementById('video-input');
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.5
            });
            
            hands.onResults((results) => {
                if(results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    if(!handDetected) {
                        handDetected = true;
                        document.getElementById('hand-indicator').style.opacity = 1;
                        document.getElementById('status').textContent = "æ‰‹åŠ¿å·²æ£€æµ‹";
                    }
                    
                    const landmarks = results.multiHandLandmarks[0];
                    
                    // è®¡ç®—æ‰‹æŒ‡å¼ å¼€ç¨‹åº¦
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const middleTip = landmarks[12];
                    const ringTip = landmarks[16];
                    const pinkyTip = landmarks[20];
                    const wrist = landmarks[0];
                    
                    // è®¡ç®—æ‰‹çš„å¤§å°ä½œä¸ºå‚è€ƒ
                    const handSize = Math.sqrt(
                        Math.pow(thumbTip.x - wrist.x, 2) +
                        Math.pow(thumbTip.y - wrist.y, 2) +
                        Math.pow(thumbTip.z - wrist.z, 2)
                    );
                    
                    // è®¡ç®—æ‰‹æŒ‡é—´è·
                    let fingerSpread = 0;
                    const tips = [indexTip, middleTip, ringTip, pinkyTip];
                    for(let i = 0; i < tips.length - 1; i++) {
                        for(let j = i + 1; j < tips.length; j++) {
                            const dist = Math.sqrt(
                                Math.pow(tips[i].x - tips[j].x, 2) +
                                Math.pow(tips[i].y - tips[j].y, 2) +
                                Math.pow(tips[i].z - tips[j].z, 2)
                            );
                            fingerSpread += dist;
                        }
                    }
                    
                    // å½’ä¸€åŒ–å¹¶æ˜ å°„åˆ°0-1èŒƒå›´
                    const normalizedSpread = fingerSpread / (handSize * 6);
                    targetMorph = THREE.MathUtils.clamp(normalizedSpread * 2, 0, 1);
                    
                    // æ›´æ–°æ‰‹åŠ¿æŒ‡ç¤ºå™¨
                    const indicator = document.getElementById('hand-indicator');
                    indicator.style.transform = `translateX(-50%) scale(${1 + targetMorph * 0.2})`;
                    indicator.style.background = `rgba(77, 255, 145, ${0.1 + targetMorph * 0.2})`;
                    indicator.textContent = targetMorph > 0.7 ? "âœ‹" : "âœŠ";
                    
                } else {
                    if(handDetected) {
                        handDetected = false;
                        document.getElementById('hand-indicator').style.opacity = 0;
                        document.getElementById('status').textContent = "ç­‰å¾…æ‰‹åŠ¿æ£€æµ‹...";
                    }
                    targetMorph = 0;
                }
            });
            
            const camera = new Camera(video, {
                onFrame: async () => {
                    await hands.send({image: video});
                },
                width: 640,
                height: 480
            });
            
            await camera.start();
            document.getElementById('loader').style.display = 'none';
            document.getElementById('ui').style.opacity = 1;
            
            setTimeout(() => {
                document.getElementById('ui').style.opacity = 0;
            }, 3000);
        }

        // --- 8. åŠ¨ç”»å¾ªç¯ ---
        function animate() {
            requestAnimationFrame(animate);
            
            const time = performance.now() * 0.001;
            
            // å¹³æ»‘å˜å½¢
            currentMorph += (targetMorph - currentMorph) * 0.05;
            particleMaterial.uniforms.morph.value = currentMorph;
            particleMaterial.uniforms.time.value = time;
            
            // æ—‹è½¬åœºæ™¯
            scene.rotation.y = time * 0.05;
            
            // åŠ¨ç”»ç‚¹å…‰æº
            pointLights.forEach((light, i) => {
                light.position.x = Math.cos(time * 0.5 + i) * 8;
                light.position.z = Math.sin(time * 0.5 + i) * 8;
                light.intensity = 0.5 + Math.sin(time * 2 + i) * 0.3;
            });
            
            // åŠ¨ç”»ç‰¹æ•ˆç²’å­
            const effectPos = effectParticles.geometry.attributes.position.array;
            const effectAttr = effectParticles.geometry.attributes.attributes.array;
            
            for(let i = 0; i < effectCount; i++) {
                const i3 = i * 3;
                const speed = effectAttr[i*2];
                const offset = effectAttr[i*2+1];
                
                effectPos[i3+1] += Math.sin(time * speed + offset) * 0.02;
                if(effectPos[i3+1] > 10) effectPos[i3+1] = -2;
            }
            effectParticles.geometry.attributes.position.needsUpdate = true;
            
            // åŠ¨ç”»é›ªèŠ±
            const snowPos = snow.geometry.attributes.position.array;
            for(let i = 0; i < snowCount; i++) {
                const i3 = i * 3;
                snowPos[i3+1] -= 0.02;
                if(snowPos[i3+1] < -5) {
                    snowPos[i3+1] = 15;
                    snowPos[i3] = (Math.random() - 0.5) * 40;
                    snowPos[i3+2] = (Math.random() - 0.5) * 40;
                }
            }
            snow.geometry.attributes.position.needsUpdate = true;
            
            // æ¸²æŸ“
            composer.render();
        }

        // --- 9. åˆå§‹åŒ– ---
        initHandTracking().catch(console.error);
        animate();

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        // ç‚¹å‡»å…¨å±
        document.addEventListener('click', () => {
            if(!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(console.log);
            }
        });
    </script>
</body>
</html>
