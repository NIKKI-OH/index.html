<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Particle Christmas</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; }
        #canvas-container { width: 100vw; height: 100vh; }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #ffd700; font-family: sans-serif; pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="loading">Initializing Magic...</div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';

        // --- 1. åœºæ™¯åˆå§‹åŒ– ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.05);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 0, 8); // ç¡®ä¿ç›¸æœºåœ¨ç‰©ä½“å¤–é¢

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- 2. åå¤„ç† (Bloom å‘å…‰) ---
        const renderScene = new RenderPass(scene, camera);
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.threshold = 0;
        bloomPass.strength = 2.0; // è°ƒé«˜å‘å…‰å¼ºåº¦
        bloomPass.radius = 0.5;

        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // --- 3. ç²’å­ç³»ç»Ÿæ ¸å¿ƒ ---
        const particleCount = 25000; // ç²’å­æ•°é‡
        const geometry = new THREE.BufferGeometry();
        
        const posGift = [];
        const posTree = [];
        const randoms = [];
        const colors = [];

        // ç”Ÿæˆé¢œè‰²
        const colorGift = new THREE.Color('#D10056'); // ç¤¼ç‰©çº¢
        const colorTreeTop = new THREE.Color('#FFD700'); // æ ‘é¡¶é‡‘
        const colorTreeBottom = new THREE.Color('#005533'); // æ ‘åº•ç»¿

        for (let i = 0; i < particleCount; i++) {
            // 1. ç¤¼ç‰©å½¢æ€ (ç«‹æ–¹ä½“)
            const x = (Math.random() - 0.5) * 3;
            const y = (Math.random() - 0.5) * 3;
            const z = (Math.random() - 0.5) * 3;
            posGift.push(x, y, z);

            // 2. åœ£è¯æ ‘å½¢æ€ (èºæ—‹åœ†é”¥)
            const angle = Math.random() * Math.PI * 2 * 5; // 5åœˆèºæ—‹
            const radius = Math.random() * 2.5 * (1 - (i / particleCount)); // åº•éƒ¨å®½é¡¶éƒ¨çª„
            const height = (i / particleCount) * 5 - 2.5;
            
            const tx = Math.cos(angle) * radius;
            const tz = Math.sin(angle) * radius;
            const ty = height;
            posTree.push(tx, ty, tz);

            // 3. éšæœºå±æ€§
            randoms.push(Math.random());

            // 4. é¢œè‰²åˆå§‹åŒ– (é»˜è®¤ç¤¼ç‰©è‰²)
            colors.push(colorGift.r, colorGift.g, colorGift.b);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(posGift, 3));
        geometry.setAttribute('targetPos', new THREE.Float32BufferAttribute(posTree, 3));
        geometry.setAttribute('initialPos', new THREE.Float32BufferAttribute(posGift, 3));
        geometry.setAttribute('aRandom', new THREE.Float32BufferAttribute(randoms, 1));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

        // --- Shader (ç€è‰²å™¨) ---
        // è¿™é‡Œçš„é­”æ³•ï¼šç”¨ mix å‡½æ•°åœ¨ä¸¤ä¸ªå½¢çŠ¶é—´å¹³æ»‘è¿‡æ¸¡
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uMorph: { value: 0 }, // 0 = ç¤¼ç‰©, 1 = æ ‘
                uColorTreeTop: { value: colorTreeTop },
                uColorTreeBottom: { value: colorTreeBottom },
                uColorGift: { value: colorGift }
            },
            vertexShader: `
                uniform float uTime;
                uniform float uMorph;
                uniform vec3 uColorTreeTop;
                uniform vec3 uColorTreeBottom;
                uniform vec3 uColorGift;
                
                attribute vec3 targetPos;
                attribute vec3 initialPos;
                attribute float aRandom;
                varying vec3 vColor;

                // ç®€å•çš„å™ªå£°å‡½æ•°
                float random (in vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                }

                void main() {
                    // ç²’å­å‘¼å¸è¿åŠ¨
                    float movement = sin(uTime * 2.0 + aRandom * 10.0) * 0.1;
                    
                    // æ··åˆä½ç½®
                    vec3 finalPos = mix(initialPos, targetPos, uMorph);
                    finalPos += normalize(finalPos) * movement; 

                    // æ··åˆé¢œè‰²
                    vec3 treeColor = mix(uColorTreeBottom, uColorTreeTop, (finalPos.y + 2.5) / 5.0);
                    vColor = mix(uColorGift, treeColor, uMorph);

                    vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                    gl_PointSize = (4.0 * aRandom + 2.0) * (10.0 / -mvPosition.z); // è¿‘å¤§è¿œå°
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                void main() {
                    // åœ†å½¢ç²’å­ + è¾‰å…‰ä¸­å¿ƒ
                    float d = distance(gl_PointCoord, vec2(0.5));
                    if(d > 0.5) discard;
                    
                    float glow = 1.0 - (d * 2.0);
                    glow = pow(glow, 2.0); // å¢å¼ºä¸­å¿ƒäº®åº¦

                    gl_FragColor = vec4(vColor, glow);
                }
            `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 4. æŠ½å¥–æ–‡å­— (ç”¨ Canvas è´´å›¾é˜²æ­¢å­—ä½“æŠ¥é”™) ---
        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'rgba(0,0,0,0)'; // é€æ˜èƒŒæ™¯
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // å‘å…‰æ–‡å­—æ•ˆæœ
            ctx.font = 'bold 80px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = '#FFD700';
            ctx.shadowColor = '#FF0000';
            ctx.shadowBlur = 20;
            ctx.fillText(text, canvas.width/2, canvas.height/2);
            
            const tex = new THREE.CanvasTexture(canvas);
            return tex;
        }

        const prizeTextPlane = new THREE.Mesh(
            new THREE.PlaneGeometry(4, 2),
            new THREE.MeshBasicMaterial({ 
                map: createTextTexture("æ­£åœ¨æŠ½å–ç¤¼ç‰©..."), 
                transparent: true, 
                opacity: 0,
                side: THREE.DoubleSide
            })
        );
        scene.add(prizeTextPlane);

        // --- 5. åŠ¨ç”»ä¸äº¤äº’é€»è¾‘ ---
        let state = 0; // 0=Gift, 1=Tree
        const prizes = ["è¯·ä½ åƒé¥­ ğŸ²", "ç­”åº”ä¸€ä¸ªè¦æ±‚ âœ¨", "æ¸…ç©ºè´­ç‰©è½¦ ğŸ›’", "çœ‹ç”µå½± ğŸ¬"];
        
        // è‡ªåŠ¨æ¼”ç¤ºå¾ªç¯
        setInterval(() => {
            state = state === 0 ? 1 : 0;
            
            // å¦‚æœå˜æˆæ ‘ï¼Œå¼€å§‹æŠ½å¥–
            if(state === 1) {
                // ç®€å•çš„æŠ½å¥–åŠ¨ç”»æ¨¡æ‹Ÿ
                let count = 0;
                const interval = setInterval(() => {
                    prizeTextPlane.material.map = createTextTexture(prizes[count % prizes.length]);
                    count++;
                    if(count > 10) { // æ»šåŠ¨10æ¬¡åœæ­¢
                        clearInterval(interval);
                        const finalPrize = prizes[Math.floor(Math.random() * prizes.length)];
                        prizeTextPlane.material.map = createTextTexture("ğŸ‰ " + finalPrize);
                    }
                }, 100);
            }
        }, 5000); // æ¯5ç§’åˆ‡æ¢ä¸€æ¬¡çŠ¶æ€

        // æ¸²æŸ“å¾ªç¯
        const clock = new THREE.Clock();
        document.getElementById('loading').style.display = 'none'; // éšè—åŠ è½½å­—

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            material.uniforms.uTime.value = time;
            controls.update();

            // å¹³æ»‘å˜å½¢
            material.uniforms.uMorph.value += (state - material.uniforms.uMorph.value) * 0.05;

            // æ–‡å­—æ˜¾ç¤ºé€»è¾‘ (å˜æˆæ ‘æ—¶æ˜¾ç¤ºï¼Œå˜æˆç¤¼ç‰©æ—¶éšè—)
            if(material.uniforms.uMorph.value > 0.8) {
                prizeTextPlane.material.opacity += (1 - prizeTextPlane.material.opacity) * 0.1;
                prizeTextPlane.lookAt(camera.position); // æ–‡å­—æ°¸è¿œæœå‘ç›¸æœº
            } else {
                prizeTextPlane.material.opacity += (0 - prizeTextPlane.material.opacity) * 0.1;
            }

            composer.render();
        }

        // çª—å£è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>
