<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle Elegance: æ‰‹åŠ¿æ§åˆ¶</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box; 
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            background: #000;
            color: #fff;
            font-family: 'Helvetica Neue', 'SF Pro Display', -apple-system, sans-serif;
            overflow: hidden;
            position: fixed;
            width: 100vw;
            height: 100vh;
            touch-action: none;
            -webkit-font-smoothing: antialiased;
        }

        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            opacity: 1;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            overflow: hidden;
        }

        .title-container {
            position: absolute;
            top: 3.5rem;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 400;
            letter-spacing: 0.2em;
            text-transform: uppercase;
            opacity: 0.95;
            animation: fadeIn 1.2s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 0.95; transform: translateY(0); }
        }

        .hand-gesture-indicator {
            position: absolute;
            bottom: 5.5rem;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            flex-direction: column;
            gap: 1.2rem;
        }

        .hand-icon {
            font-size: 3.5rem;
            width: 4rem;
            height: 4rem;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            filter: drop-shadow(0 4px 12px rgba(255, 255, 255, 0.15));
        }

        .gesture-text {
            font-size: 1rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            opacity: 0.9;
            white-space: nowrap;
            transition: opacity 0.3s ease;
        }

        .transformation-line {
            position: absolute;
            bottom: 9rem;
            left: 50%;
            transform: translateX(-50%);
            width: 160px;
            height: 1px;
            background: rgba(255, 255, 255, 0.2);
            overflow: hidden;
        }

        .transformation-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, 
                rgba(220, 50, 70, 0.9) 0%, 
                rgba(255, 200, 50, 0.9) 50%, 
                rgba(80, 220, 150, 0.9) 100%);
            transition: width 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        .transformation-dots {
            position: absolute;
            bottom: 8.8rem;
            left: 50%;
            transform: translateX(-50%);
            width: 160px;
            display: flex;
            justify-content: space-between;
        }

        .transformation-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: all 0.3s ease;
        }

        .transformation-dot.active {
            background: rgba(255, 255, 255, 0.95);
            transform: scale(1.3);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.4);
        }

        .logo {
            position: absolute;
            bottom: 2rem;
            left: 2rem;
            font-size: 0.9rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            opacity: 0.5;
            transition: opacity 0.3s ease;
        }

        .instruction {
            position: absolute;
            bottom: 2rem;
            right: 2rem;
            font-size: 0.9rem;
            font-weight: 300;
            letter-spacing: 0.1em;
            opacity: 0.5;
            text-align: right;
        }

        .permission-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .permission-content {
            text-align: center;
            padding: 3rem;
            max-width: 500px;
        }

        .permission-title {
            font-size: 1.4rem;
            margin-bottom: 1.5rem;
            font-weight: 300;
            letter-spacing: 0.1em;
        }

        .permission-description {
            font-size: 1rem;
            line-height: 1.6;
            opacity: 0.8;
            margin-bottom: 2.5rem;
            font-weight: 300;
        }

        .permission-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 1rem 2.5rem;
            font-size: 1rem;
            border-radius: 2rem;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 300;
            letter-spacing: 0.1em;
            backdrop-filter: blur(10px);
        }

        .permission-button:hover {
            background: rgba(255, 255, 255, 0.15);
            border-color: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .permission-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        @media (max-width: 768px) {
            .title-container { top: 2.5rem; font-size: 0.9rem; }
            .hand-gesture-indicator { bottom: 4.5rem; }
            .hand-icon { font-size: 2.8rem; }
            .gesture-text { font-size: 0.9rem; }
        }
    </style>
</head>
<body>
    <canvas id="mainCanvas"></canvas>
    
    <div id="ui">
        <div class="title-container">Gesture Particle Transformation</div>
        
        <div class="hand-gesture-indicator">
            <div class="hand-icon">âœŠ</div>
            <div class="gesture-text">æ¡æ‹³ - ç¤¼ç‰©å½¢æ€</div>
        </div>
        
        <div class="transformation-dots">
            <div class="transformation-dot active"></div>
            <div class="transformation-dot"></div>
        </div>
        
        <div class="transformation-line">
            <div class="transformation-progress" id="progressFill"></div>
        </div>
        
        <div class="logo">PARTICLE ELEGANCE</div>
        <div class="instruction">è¯·å°†æ‰‹ç½®äºæ‘„åƒå¤´å‰</div>
    </div>
    
    <div class="permission-overlay" id="permissionOverlay">
        <div class="permission-content">
            <div class="permission-title">æ‰‹åŠ¿æ§åˆ¶ä½“éªŒ</div>
            <div class="permission-description">
                è¿™æ˜¯ä¸€ä¸ªé€šè¿‡æ‰‹åŠ¿æ§åˆ¶çš„ç²’å­å˜æ¢ä½“éªŒã€‚<br>
                è¯·å…è®¸æ‘„åƒå¤´è®¿é—®æƒé™ï¼Œå°†æ‚¨çš„æ‰‹ç½®äºæ‘„åƒå¤´å‰ï¼Œ<br>
                é€šè¿‡æ¡æ‹³å’Œå¼ æ‰‹æ¥æ§åˆ¶ç²’å­åœ¨ç¤¼ç‰©ä¸åœ£è¯æ ‘å½¢æ€é—´å˜æ¢ã€‚
            </div>
            <button class="permission-button" id="startButton">å¼€å§‹ä½“éªŒ</button>
        </div>
    </div>

    <video id="videoInput" autoplay playsinline style="display: none;"></video>

    <!-- ä½¿ç”¨ç‰¹å®šç‰ˆæœ¬çš„ Three.jsï¼Œç¡®ä¿ç¨³å®šæ€§ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>

    <script>
        // é…ç½®å‚æ•°
        const CONFIG = {
            particleCount: 18000,
            particleSize: 0.08,
            animationSpeed: 0.08,
            rotationSpeed: 0.002,
            handSmoothing: 0.15,
            maxRotationAngle: Math.PI * 0.02,
            colors: {
                giftPrimary: new THREE.Color(0xC40C2C),   // ä¼˜é›…çš„æ·±çº¢è‰²
                giftAccent: new THREE.Color(0xD4AF37),    // é‡‘è‰²
                treePrimary: new THREE.Color(0x2D5A27),   // æ·±æ£®æ—ç»¿
                treeSecondary: new THREE.Color(0x3A8C3A), // ä¸­ç»¿è‰²
                treeAccent: new THREE.Color(0xFFD700),    // äº®é‡‘è‰²
                ornament1: new THREE.Color(0xC40C2C),     // è£…é¥°çƒçº¢
                ornament2: new THREE.Color(0x1E90FF),     // è£…é¥°çƒè“
                ornament3: new THREE.Color(0xFFD700),     // è£…é¥°çƒé‡‘
                star: new THREE.Color(0xFFEEAA)           // æ˜Ÿæ˜Ÿ
            }
        };

        // å…¨å±€å˜é‡
        let scene, camera, renderer;
        let particles, particleGeometry, particleMaterial;
        let currentMorph = 0, targetMorph = 0;
        let handDetected = false;
        let lastHandTime = 0;
        let hands = null;
        let animationFrameId = null;
        let lastUpdateTime = 0;

        // åˆå§‹åŒ–
        class ParticleTransformation {
            constructor() {
                this.initializeScene();
                this.initializeParticles();
                this.initializeEventListeners();
                this.animate(0);
            }

            initializeScene() {
                // åˆ›å»ºåœºæ™¯
                scene = new THREE.Scene();
                
                // åˆ›å»ºç›¸æœº
                const aspect = window.innerWidth / window.innerHeight;
                camera = new THREE.PerspectiveCamera(50, aspect, 0.1, 1000);
                camera.position.set(0, 0, 14);
                camera.lookAt(0, 0, 0);
                
                // åˆ›å»ºæ¸²æŸ“å™¨
                renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('mainCanvas'),
                    antialias: true,
                    alpha: true,
                    powerPreference: "high-performance",
                    precision: "highp"
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                renderer.outputEncoding = THREE.sRGBEncoding;
                
                // æ·»åŠ ç¯å¢ƒå…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
                scene.add(ambientLight);
                
                // æ·»åŠ ä¸»å…‰æº
                const mainLight = new THREE.DirectionalLight(0xffffff, 0.7);
                mainLight.position.set(8, 10, 8);
                scene.add(mainLight);
                
                // æ·»åŠ èƒŒå…‰
                const backLight = new THREE.DirectionalLight(0x6688ff, 0.3);
                backLight.position.set(-5, -3, -8);
                scene.add(backLight);
            }

            initializeParticles() {
                const count = CONFIG.particleCount;
                const geometry = new THREE.BufferGeometry();
                
                // åˆ›å»ºæ•°ç»„
                const positions = new Float32Array(count * 3);
                const targetPositions = new Float32Array(count * 3);
                const colors = new Float32Array(count * 3);
                const sizes = new Float32Array(count);
                const phases = new Float32Array(count);
                const types = new Float32Array(count);
                
                for (let i = 0; i < count; i++) {
                    const i3 = i * 3;
                    const random = Math.random();
                    
                    // ç¡®å®šç²’å­ç±»å‹
                    let type = 0; // é»˜è®¤ï¼šçº¢è‰²ç¤¼ç‰©
                    if (i < 400) {
                        type = 4; // æ˜Ÿæ˜Ÿ
                    } else if (random < 0.15) {
                        type = 1; // é‡‘è‰²ä¸å¸¦
                    } else if (random < 0.3) {
                        type = 2; // è£…é¥°çƒ
                    } else if (random < 0.8) {
                        type = 3; // ç»¿è‰²æ ‘å¶
                    }
                    
                    types[i] = type;
                    phases[i] = Math.random() * Math.PI * 2;
                    
                    // ç¤¼ç‰©ä½ç½®ï¼ˆç²¾ç»†çš„ç«‹æ–¹ä½“ï¼‰
                    const giftSize = 3.8;
                    const face = Math.floor(Math.random() * 6);
                    const u = (Math.random() - 0.5) * 2 * giftSize;
                    const v = (Math.random() - 0.5) * 2 * giftSize;
                    
                    switch(face) {
                        case 0: positions[i3] = giftSize; positions[i3+1] = u; positions[i3+2] = v; break;
                        case 1: positions[i3] = -giftSize; positions[i3+1] = u; positions[i3+2] = v; break;
                        case 2: positions[i3] = u; positions[i3+1] = giftSize; positions[i3+2] = v; break;
                        case 3: positions[i3] = u; positions[i3+1] = -giftSize; positions[i3+2] = v; break;
                        case 4: positions[i3] = u; positions[i3+1] = v; positions[i3+2] = giftSize; break;
                        case 5: positions[i3] = u; positions[i3+1] = v; positions[i3+2] = -giftSize; break;
                    }
                    
                    // åœ£è¯æ ‘ä½ç½®ï¼ˆç²¾è‡´çš„èºæ—‹ç»“æ„ï¼‰
                    if (type === 4) {
                        // æ˜Ÿæ˜Ÿï¼ˆé¡¶éƒ¨ï¼‰
                        const starAngle = (i / 400) * Math.PI * 10;
                        const starRadius = 1.8 * Math.sin(starAngle * 2.5) * 0.5 + 1.2;
                        targetPositions[i3] = Math.cos(starAngle) * starRadius * 0.8;
                        targetPositions[i3+1] = 7.5 + Math.sin(starAngle * 5) * 0.2;
                        targetPositions[i3+2] = Math.sin(starAngle) * starRadius * 0.8;
                    } else {
                        const t = (i - 400) / (count - 400);
                        const height = t * 11 - 3;
                        const radius = Math.pow(1.1 - t, 1.3) * 4.5;
                        const angle = Math.PI * 8 * t + (Math.floor(Math.random() * 12) * Math.PI / 6);
                        const noise = (Math.random() - 0.5) * 0.4;
                        
                        targetPositions[i3] = Math.cos(angle) * (radius + noise);
                        targetPositions[i3+1] = height;
                        targetPositions[i3+2] = Math.sin(angle) * (radius + noise);
                        
                        // è£…é¥°çƒç¨å‘å¤–
                        if (type === 2) {
                            targetPositions[i3] *= 1.25;
                            targetPositions[i3+2] *= 1.25;
                        }
                    }
                    
                    // è®¾ç½®é¢œè‰²
                    const color = new THREE.Color();
                    switch(type) {
                        case 0: color.copy(CONFIG.colors.giftPrimary); break;
                        case 1: color.copy(CONFIG.colors.giftAccent); break;
                        case 2: 
                            const ornamentType = i % 3;
                            if (ornamentType === 0) color.copy(CONFIG.colors.ornament1);
                            else if (ornamentType === 1) color.copy(CONFIG.colors.ornament2);
                            else color.copy(CONFIG.colors.ornament3);
                            break;
                        case 3: 
                            const greenMix = (targetPositions[i3+1] + 3) / 11;
                            color.copy(CONFIG.colors.treePrimary).lerp(CONFIG.colors.treeSecondary, greenMix);
                            break;
                        case 4: color.copy(CONFIG.colors.star); break;
                    }
                    
                    colors[i3] = color.r;
                    colors[i3+1] = color.g;
                    colors[i3+2] = color.b;
                    
                    // è®¾ç½®å¤§å°
                    sizes[i] = CONFIG.particleSize * (0.8 + Math.random() * 0.4);
                    if (type === 1 || type === 4) sizes[i] *= 1.3; // é‡‘è‰²å’Œæ˜Ÿæ˜Ÿæ›´å¤§
                    if (type === 2) sizes[i] *= 1.5; // è£…é¥°çƒæœ€å¤§
                }
                
                // è®¾ç½®å‡ ä½•ä½“å±æ€§
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('targetPosition', new THREE.BufferAttribute(targetPositions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
                
                // åˆ›å»ºæè´¨
                particleMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        morph: { value: 0 },
                        aspect: { value: window.innerWidth / window.innerHeight }
                    },
                    vertexShader: `
                        uniform float time;
                        uniform float morph;
                        uniform float aspect;
                        
                        attribute vec3 targetPosition;
                        attribute float size;
                        attribute float phase;
                        
                        varying vec3 vColor;
                        varying float vAlpha;
                        
                        void main() {
                            // å¹³æ»‘æ’å€¼
                            float t = morph;
                            t = t * t * (3.0 - 2.0 * t); // ä¸‰æ¬¡ç¼“åŠ¨
                            
                            // ä½ç½®æ’å€¼
                            vec3 pos = mix(position, targetPosition, t);
                            
                            // å¾®å¦™çš„æµ®åŠ¨åŠ¨ç”»
                            float floatOffset = sin(time * 1.2 + phase) * 0.06;
                            pos.y += floatOffset * (1.0 - t * 0.3);
                            
                            // ç¤¼ç‰©çŠ¶æ€ä¸‹çš„æ—‹è½¬
                            float rotation = time * 0.4 * (1.0 - t);
                            float c = cos(rotation);
                            float s = sin(rotation);
                            pos.xz = mat2(c, -s, s, c) * pos.xz;
                            
                            // ä¼ é€’é¢œè‰²
                            vColor = color;
                            
                            // è®¡ç®—é€æ˜åº¦
                            vAlpha = 0.92 + 0.08 * sin(time * 0.8 + phase);
                            
                            // è®¡ç®—æœ€ç»ˆä½ç½®
                            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                            gl_Position = projectionMatrix * mvPosition;
                            
                            // ç‚¹å¤§å°
                            gl_PointSize = size * (350.0 / -mvPosition.z);
                        }
                    `,
                    fragmentShader: `
                        varying vec3 vColor;
                        varying float vAlpha;
                        
                        void main() {
                            // åœ†å½¢ç‚¹ç²¾çµ
                            vec2 uv = gl_PointCoord - 0.5;
                            float dist = length(uv);
                            
                            if (dist > 0.5) discard;
                            
                            // æŸ”å’Œçš„è¾¹ç¼˜
                            float alpha = 1.0 - smoothstep(0.35, 0.5, dist);
                            
                            // è½»å¾®çš„å†…éƒ¨å‘å…‰
                            float innerGlow = 1.0 - dist * 1.6;
                            innerGlow = pow(innerGlow, 2.0);
                            
                            // æœ€ç»ˆé¢œè‰²
                            gl_FragColor = vec4(vColor, alpha * innerGlow * vAlpha);
                        }
                    `,
                    transparent: true,
                    depthWrite: false,
                    blending: THREE.AdditiveBlending,
                    vertexColors: true
                });
                
                // åˆ›å»ºç²’å­ç³»ç»Ÿ
                particles = new THREE.Points(geometry, particleMaterial);
                scene.add(particles);
            }

            initializeEventListeners() {
                window.addEventListener('resize', () => {
                    camera.aspect = window.innerWidth / window.innerHeight;
                    camera.updateProjectionMatrix();
                    renderer.setSize(window.innerWidth, window.innerHeight);
                    if (particleMaterial && particleMaterial.uniforms.aspect) {
                        particleMaterial.uniforms.aspect.value = window.innerWidth / window.innerHeight;
                    }
                });
                
                // å¼€å§‹æŒ‰é’®
                document.getElementById('startButton').addEventListener('click', () => {
                    document.getElementById('permissionOverlay').classList.add('hidden');
                    this.initializeHandTracking();
                });
            }

            async initializeHandTracking() {
                const video = document.getElementById('videoInput');
                
                try {
                    // è·å–æ‘„åƒå¤´æƒé™
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: {
                            width: { ideal: 640 },
                            height: { ideal: 480 },
                            facingMode: 'user'
                        }
                    });
                    
                    video.srcObject = stream;
                    
                    // åˆå§‹åŒ–æ‰‹åŠ¿è¯†åˆ«
                    hands = new Hands({
                        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
                    });
                    
                    hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.6,
                        minTrackingConfidence: 0.6
                    });
                    
                    hands.onResults(this.handleHandResults.bind(this));
                    
                    // å¯åŠ¨æ‘„åƒå¤´
                    const camera = new Camera(video, {
                        onFrame: async () => {
                            if (hands) {
                                await hands.send({ image: video });
                            }
                        },
                        width: 640,
                        height: 480
                    });
                    
                    await camera.start();
                    
                } catch (error) {
                    console.error('æ‘„åƒå¤´åˆå§‹åŒ–å¤±è´¥:', error);
                    // å¦‚æœæ²¡æœ‰æ‘„åƒå¤´ï¼Œå…è®¸é¼ æ ‡æ§åˆ¶
                    this.enableMouseControl();
                }
            }

            handleHandResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const landmarks = results.multiHandLandmarks[0];
                    const now = Date.now();
                    
                    // è®¡ç®—æ‰‹æŒ‡å¼ å¼€ç¨‹åº¦
                    const thumbTip = landmarks[4];
                    const indexTip = landmarks[8];
                    const middleTip = landmarks[12];
                    const ringTip = landmarks[16];
                    const pinkyTip = landmarks[20];
                    const wrist = landmarks[0];
                    
                    // è®¡ç®—æ‰€æœ‰æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»
                    const distances = [
                        this.calculateDistance(thumbTip, wrist),
                        this.calculateDistance(indexTip, wrist),
                        this.calculateDistance(middleTip, wrist),
                        this.calculateDistance(ringTip, wrist),
                        this.calculateDistance(pinkyTip, wrist)
                    ];
                    
                    // è®¡ç®—å¹³å‡è·ç¦»å¹¶å½’ä¸€åŒ–
                    const avgDistance = distances.reduce((a, b) => a + b) / distances.length;
                    const normalizedDistance = Math.min(Math.max((avgDistance - 0.08) / 0.15, 0), 1);
                    
                    // ä½¿ç”¨ç¼“åŠ¨å‡½æ•°å¹³æ»‘å€¼
                    targetMorph = this.smoothStep(normalizedDistance);
                    
                    // æ›´æ–°UI
                    this.updateUI(targetMorph);
                    
                    lastHandTime = now;
                    if (!handDetected) {
                        handDetected = true;
                    }
                    
                } else {
                    // æ²¡æœ‰æ£€æµ‹åˆ°æ‰‹ï¼Œæ…¢æ…¢å›å½’åˆ°0
                    if (handDetected && Date.now() - lastHandTime > 500) {
                        handDetected = false;
                    }
                }
            }

            calculateDistance(point1, point2) {
                const dx = point1.x - point2.x;
                const dy = point1.y - point2.y;
                const dz = point1.z - point2.z;
                return Math.sqrt(dx * dx + dy * dy + dz * dz);
            }

            smoothStep(x) {
                return x * x * (3 - 2 * x);
            }

            updateUI(morphValue) {
                const progressFill = document.getElementById('progressFill');
                const handIcon = document.querySelector('.hand-icon');
                const gestureText = document.querySelector('.gesture-text');
                const dots = document.querySelectorAll('.transformation-dot');
                
                // æ›´æ–°è¿›åº¦æ¡
                progressFill.style.width = `${morphValue * 100}%`;
                
                // æ›´æ–°æ‰‹åŠ¿å›¾æ ‡å’Œæ–‡å­—
                if (morphValue < 0.3) {
                    handIcon.textContent = 'âœŠ';
                    handIcon.style.transform = 'scale(1)';
                    gestureText.textContent = 'æ¡æ‹³ - ç¤¼ç‰©å½¢æ€';
                    dots[0].classList.add('active');
                    dots[1].classList.remove('active');
                } else if (morphValue > 0.7) {
                    handIcon.textContent = 'ğŸ–ï¸';
                    handIcon.style.transform = 'scale(1.1)';
                    gestureText.textContent = 'å¼ æ‰‹ - åœ£è¯æ ‘å½¢æ€';
                    dots[0].classList.remove('active');
                    dots[1].classList.add('active');
                } else {
                    handIcon.textContent = 'âœ‹';
                    const scale = 1 + (morphValue - 0.3) * 0.25;
                    handIcon.style.transform = `scale(${scale})`;
                    gestureText.textContent = 'å˜æ¢ä¸­...';
                    dots[0].classList.remove('active');
                    dots[1].classList.remove('active');
                }
            }

            enableMouseControl() {
                let mouseDown = false;
                let mouseValue = 0;
                
                document.addEventListener('mousedown', (e) => {
                    mouseDown = true;
                    this.updateMouseValue(e.clientX);
                });
                
                document.addEventListener('mousemove', (e) => {
                    if (mouseDown) {
                        this.updateMouseValue(e.clientX);
                    }
                });
                
                document.addEventListener('mouseup', () => {
                    mouseDown = false;
                });
                
                document.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    mouseDown = true;
                    this.updateMouseValue(e.touches[0].clientX);
                });
                
                document.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (mouseDown) {
                        this.updateMouseValue(e.touches[0].clientX);
                    }
                });
                
                document.addEventListener('touchend', () => {
                    mouseDown = false;
                });
            }

            updateMouseValue(clientX) {
                const width = window.innerWidth;
                mouseValue = Math.min(Math.max(clientX / width, 0), 1);
                targetMorph = mouseValue;
                this.updateUI(targetMorph);
            }

            animate(timestamp) {
                animationFrameId = requestAnimationFrame(this.animate.bind(this));
                
                // è®¡ç®—æ—¶é—´å¢é‡
                const deltaTime = timestamp - lastUpdateTime || 0;
                lastUpdateTime = timestamp;
                const time = timestamp * 0.001;
                
                // å¹³æ»‘è¿‡æ¸¡
                const smoothing = handDetected ? CONFIG.handSmoothing : 0.05;
                currentMorph += (targetMorph - currentMorph) * smoothing;
                
                // æ›´æ–°ç²’å­æè´¨
                if (particleMaterial) {
                    particleMaterial.uniforms.time.value = time;
                    particleMaterial.uniforms.morph.value = currentMorph;
                }
                
                // ç¼“æ…¢çš„è‡ªåŠ¨æ—‹è½¬
                if (particles) {
                    particles.rotation.y += CONFIG.rotationSpeed * (1 - currentMorph * 0.5);
                    
                    // è½»å¾®çš„æ‘†åŠ¨
                    particles.rotation.x = Math.sin(time * 0.3) * CONFIG.maxRotationAngle * (1 - currentMorph);
                    particles.rotation.z = Math.cos(time * 0.2) * CONFIG.maxRotationAngle * (1 - currentMorph) * 0.5;
                }
                
                // æ¸²æŸ“
                renderer.render(scene, camera);
            }

            destroy() {
                if (animationFrameId) {
                    cancelAnimationFrame(animationFrameId);
                }
                if (renderer) {
                    renderer.dispose();
                }
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        let app;
        window.addEventListener('DOMContentLoaded', () => {
            app = new ParticleTransformation();
        });

        // æ¸…ç†
        window.addEventListener('beforeunload', () => {
            if (app) {
                app.destroy();
            }
        });
    </script>
</body>
</html>
