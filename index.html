<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Winter Gift | Luxury Edition</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Noto+Sans+SC:wght@300&display=swap');

    body { margin: 0; overflow: hidden; background-color: #000000; font-family: 'Noto Sans SC', sans-serif; }
    
    #ui-layer {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 10;
        display: flex; flex-direction: column; justify-content: center; align-items: center;
        background: radial-gradient(circle, transparent 40%, rgba(0,0,0,0.9) 100%);
    }

    /* 文字更纤细，更高雅 */
    h1 {
        font-family: 'Cinzel', serif; color: #F0E68C; 
        font-size: 20px; letter-spacing: 8px; text-transform: uppercase; font-weight: 400;
        margin-top: -100px; text-align: center; opacity: 0.8;
        text-shadow: 0 0 15px rgba(240, 230, 140, 0.3);
    }
    
    .btn-hint {
        color: rgba(255,255,255,0.3); font-size: 10px; letter-spacing: 4px; margin-top: 15px;
        border: 1px solid rgba(255,255,255,0.1); padding: 8px 20px; border-radius: 20px;
        background: rgba(0,0,0,0.5); backdrop-filter: blur(2px);
    }

</style>
<script src="https://lib.baomitu.com/three.js/r128/three.min.js"></script>
<script src="https://lib.baomitu.com/tween.js/18.6.4/tween.umd.js"></script>
</head>
<body>

<div id="ui-layer">
    <div>
        <h1>The Winter Gift</h1>
        <div class="btn-hint">TAP TO OPEN</div>
    </div>
</div>

<div id="canvas-container"></div>

<script>
    // --- 1. 高奢审美配置 (Aesthetics) ---
    const CONFIG = {
        count: 25000, // 粒子量大，但单体极小
        colors: {
            red: new THREE.Color(0x8B0000),      // 深红 (Dark Red) - 礼物盒
            gold: new THREE.Color(0xFFFACD),     // 柠檬绸金 (Lemon Chiffon) - 亮部
            green: new THREE.Color(0x002211),    // 极深绿 (Dark Emerald) - 树主体
            cyan: new THREE.Color(0x004433)      // 青绿 (Teal) - 树层次
        }
    };

    // --- 2. 场景 ---
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.04); // 更重的黑色雾气，增加深邃感

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 0, 7.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false }); // 关闭透明背景，强制纯黑，防止泛白
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    document.body.appendChild(renderer.domElement);

    // --- 3. 核心：微粒光点纹理 (Micro-Sparkle) ---
    function createSparkleTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        
        // 核心改动：不再画大光晕，而是画锐利的星点
        const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        grad.addColorStop(0, 'rgba(255, 255, 255, 1)');     // 极亮核心
        grad.addColorStop(0.15, 'rgba(255, 255, 255, 0.3)'); // 快速衰减
        grad.addColorStop(0.5, 'rgba(0, 0, 0, 0)');          // 边缘完全透明
        
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, 64, 64);
        return new THREE.CanvasTexture(canvas);
    }

    // --- 4. 抽奖文字 (全息板) ---
    const PRIZES = ["请你吃大餐", "清空购物车", "专属奶茶一杯", "答应一个要求", "现金红包 520", "看一场电影"];
    const CHEAT_CODE = null; // 设置作弊词，如 "清空购物车"

    function createTextTexture(text, isHighlight) {
        const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=256;
        const ctx = cvs.getContext('2d');
        if(isHighlight) {
            const g = ctx.createRadialGradient(256,128,0,256,128,150);
            g.addColorStop(0,'rgba(255,250,205,0.2)'); g.addColorStop(1,'rgba(0,0,0,0)');
            ctx.fillStyle=g; ctx.fillRect(0,0,512,256);
        }
        ctx.font = "bold 50px 'Noto Sans SC', sans-serif";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.shadowBlur=isHighlight?20:10; ctx.shadowColor=isHighlight?"#FFFACD":"#AFEEEE";
        ctx.fillStyle=isHighlight?"#FFFFFF":"#E0FFFF";
        ctx.fillText(text, 256, 128);
        const t=new THREE.CanvasTexture(cvs); t.needsUpdate=true; return t;
    }
    const textMat = new THREE.MeshBasicMaterial({ map: createTextTexture(""), transparent:true, opacity:0, blending:THREE.AdditiveBlending, depthTest:false });
    const textMesh = new THREE.Mesh(new THREE.PlaneGeometry(2.5,1.25), textMat);
    textMesh.position.set(0,0.2,0); scene.add(textMesh);


    // --- 5. 粒子系统 (重写排布逻辑) ---
    const geo = new THREE.BufferGeometry();
    const pos=[], col=[], sizes=[], randoms=[];
    const tGift=[], tTree=[], cGift=[], cTree=[];

    for(let i=0; i<CONFIG.count; i++) {
        randoms.push(Math.random());

        // --- 礼物盒 (Cube) ---
        // 改动：让礼物盒看起来更像是一个“能量块”，而不是空心盒子
        let gx = (Math.random()-0.5)*2.5;
        let gy = (Math.random()-0.5)*2.5;
        let gz = (Math.random()-0.5)*2.5;
        
        // 边缘更密集 (勾勒轮廓)
        if(Math.random()>0.5) {
            let axis = Math.floor(Math.random()*3);
            if(axis===0) gx = Math.sign(gx)*1.25;
            if(axis===1) gy = Math.sign(gy)*1.25;
            if(axis===2) gz = Math.sign(gz)*1.25;
        }

        tGift.push(gx, gy, gz);
        // 礼物颜色：深红 + 少量金色火花
        let cG = (Math.random()>0.9) ? CONFIG.colors.gold : CONFIG.colors.red;
        cGift.push(cG.r, cG.g, cG.b);


        // --- 圣诞树 (Ethereal Tree) ---
        // 核心改动：不仅在表面，内部也要填充粒子，制造“体积雾”感
        let angle = i * 0.15;
        let h = (i/CONFIG.count)*7 - 3.5; // 高度
        let rBase = (3.5 - h) * 0.45;     // 锥体半径
        
        let r = rBase * Math.sqrt(Math.random()); // 随机分布在圆内，而不是圆周上
        let tx = Math.cos(angle)*r;
        let ty = h;
        let tz = Math.sin(angle)*r;

        // 颜色逻辑：
        // 内部深绿，外部浅绿，夹杂金粉
        let distRatio = r / rBase; // 0=中心, 1=边缘
        let cT = CONFIG.colors.green.clone().lerp(CONFIG.colors.cyan, distRatio * 0.5);
        
        let size = Math.random()*0.08 + 0.02; // 默认极小

        // --- 金色流沙 (替代原本生硬的螺旋) ---
        // 只有 5% 的粒子构成流光，若隐若现
        if (i % 20 === 0) {
            let rSpiral = rBase * 1.05; // 紧贴表面浮动
            let spiralAngle = angle * 2 + h; // 动态螺旋
            tx = Math.cos(spiralAngle) * rSpiral;
            tz = Math.sin(spiralAngle) * rSpiral;
            cT = CONFIG.colors.gold;
            size = Math.random()*0.15 + 0.05; // 流光稍大
        }
        // 树顶之星
        if(h > 3.2) { 
            tx*=0.1; tz*=0.1; cT = CONFIG.colors.gold; size = 0.2; 
        }

        tTree.push(tx, ty, tz);
        cTree.push(cT.r, cT.g, cT.b);

        // 初始化
        pos.push(gx, gy, gz);
        col.push(cG.r, cG.g, cG.b);
        sizes.push(size);
    }

    geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
    geo.setAttribute('color', new THREE.Float32BufferAttribute(col, 3));
    geo.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

    // --- 材质 (关键修正：降低曝光) ---
    const mat = new THREE.PointsMaterial({
        vertexColors: true,
        map: createSparkleTexture(),
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        transparent: true,
        opacity: 0.4, // 【关键】大幅降低透明度，防止重叠变白！
        sizeAttenuation: true
    });
    const particles = new THREE.Points(geo, mat);
    scene.add(particles);

    // --- 6. 动画逻辑 ---
    let state = 'gift';
    let morph = 0;
    let time = 0;
    let spinTimer = null;

    function animate() {
        requestAnimationFrame(animate);
        TWEEN.update();
        time += 0.01;

        const p = geo.attributes.position.array;
        const c = geo.attributes.color.array;

        // 粒子变形插值
        for(let i=0; i<CONFIG.count; i++) {
            const ix=i*3, iy=i*3+1, iz=i*3+2;
            
            // 基础位置
            const px = tGift[ix]*(1-morph) + tTree[ix]*morph;
            const py = tGift[iy]*(1-morph) + tTree[iy]*morph;
            const pz = tGift[iz]*(1-morph) + tTree[iz]*morph;
            
            // 动态湍流 (Turbulence) - 让粒子像烟雾一样飘动
            const noise = Math.sin(time + py*0.5 + randoms[i]*10) * 0.05;
            
            p[ix] = px + Math.cos(time + randoms[i])*0.02 + noise;
            p[iy] = py + Math.sin(time*0.5 + randoms[i])*0.02;
            p[iz] = pz + Math.sin(time + randoms[i])*0.02 + noise;

            // 颜色插值
            c[ix] = cGift[ix]*(1-morph) + cTree[ix]*morph;
            c[iy] = cGift[iy]*(1-morph) + cTree[iy]*morph;
            c[iz] = cGift[iz]*(1-morph) + cTree[iz]*morph;
        }
        geo.attributes.position.needsUpdate = true;
        geo.attributes.color.needsUpdate = true;

        particles.rotation.y = time * 0.08;
        
        // 文字浮动
        textMesh.lookAt(camera.position);
        renderer.render(scene, camera);
    }
    animate();

    // --- 7. 交互流程 ---
    function start() {
        if(state !== 'gift') return;
        state = 'spinning';
        
        // UI 消失
        const ui = document.querySelector('#ui-layer');
        ui.style.opacity = 0;
        setTimeout(()=>ui.style.display='none', 1000);

        // 变形动画
        new TWEEN.Tween({v:0}).to({v:1}, 2500).easing(TWEEN.Easing.Cubic.InOut)
            .onUpdate(o => morph=o.v).start();

        // 抽奖逻辑
        textMat.opacity = 1;
        let idx = 0;
        spinTimer = setInterval(() => {
            textMat.map = createTextTexture(PRIZES[idx % PRIZES.length], false);
            idx++;
        }, 100);

        // 3.5秒后出结果
        setTimeout(() => {
            clearInterval(spinTimer);
            const res = CHEAT_CODE || PRIZES[Math.floor(Math.random()*PRIZES.length)];
            textMat.map = createTextTexture(res, true);
            
            // 结果高亮冲击
            new TWEEN.Tween(textMesh.scale).from({x:0.1,y:0.1}).to({x:1,y:1}, 800).easing(TWEEN.Easing.Elastic.Out).start();
            
            // 粒子爆发扩散一下 (Shockwave visual)
            state = 'done';
        }, 3500);
    }

    window.addEventListener('mousedown', start);
    window.addEventListener('touchstart', (e)=>{e.preventDefault(); start();}, {passive:false});
    window.addEventListener('resize', () => {
        camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
